
>[!check] `userprog/syscall.h` 안 ==시스템 콜 핸들러== 구현
>시스템 콜 번호를 받아오고, 어떤 시스템 콜 인자들을 받아오고, 그에 알맞은 액션을 취해야 한다.


## 인터럽트
### ✓ 외부 인터럽트

운영 체제가 유저 프로그램에게서 제어권을 되찾아 갈 수 있는 방법 : 외부 인터럽트
첫 프로젝트에서 이미 다루었다.

>타이머와 I/O 디바이스들로부터의 인터럽트 : CPU 외부의 독립적인 장치가 야기하는 외부 인터럽트


### ✓ 내부 인터럽트 (Software interrupt)

프로그램 코드에 발생하는 이벤트
page fault, division by zero...
  
>SW exception : 유저 프로그램이 “시스템 콜” 이라는 서비스를 운영체제에게 요청하는 수단

>[!check] Exception의 종류 2가지
> 1. External device 로부터의 Hardware interrupt : Interrupt
> 2. User로 부터의 Software exception (fault, trap, abort)

## 시스템 콜
전통적인 x86 아키텍쳐에서 시스템 콜은 다른 sw exception과 동일하게 취급
하지만 x86-64에서는 제조사가 `syscall` 이라는 시스템 콜을 위한 특별한 명령어를 제공
이 명령어는 시스템 콜 핸들러를 호출하는 빠른 방법을 제공

>[!check] `syscall` 명령어 
>x86-64에서 시스템 콜을 불러올 때 가장 흔하게 사용되는 수단
> Pintos에서 유저 프로그램은 시스템 콜을 만들기 위해서 `syscall` 호출
> `syscall` 명령어를 불러오기 전, 
> 시스템 콜 번호와 추가적인 인자는 레지스터에 일반적인 방법으로 설정
> 
> 이때 일반적이지 않은 점 두 가지
> 1. `%rax`는 시스템 콜 번호
> 2. 4번째 인자는 `%rcx`가 아니라 `%r10`
> 
> 따라서 시스템 콜 핸들러 `syscall_handler()`가 제어권을 얻으면 
> 시스템 콜 번호는 `%rax`에,
> 인자는 `%rdi`, `%rsi`, `%rdx`, `%r10`, `%r8`, `%r9` 순서로 전달

시스템 콜 핸들러를 호출한 콜러의 레지스터는 전달받은 `struct intr_frame` 에 접근할 수 있습니다. (`struct intr_frame`은 커널 스택에 있습니다.

함수 리턴 값을 위한 x86-64의 관례는 그 값을 `RAX` 레지스터에 넣는 것 입니다. 
값을 리턴하는 시스템 콜도 `struct intr_frame`의 `rax` 멤버를 수정하는 식으로 이 관례를 따를 수 있습니다.

>[!check] `%rax` 레지스터
>지금까지 나온 `%rax`레지스터의 역할
>1. 시스템 콜 번호 저장
>2. 함수 리턴 값 저장


## 구현해야 할 시스템 콜

>`include/lib/user/syscall.h` 을 포함하는 유저 프로그램이 보게되는 시스템 콜들의 프로토타입 목록 입니다. (이 헤더파일과 include/lib/user 에 있는 모든 건 유저 프로그램만 사용합니다.) 
>각 시스템 콜의 시스템 콜 번호는 include/lib/syscall-nr.h 에 정의 되어 있습니다.


```c
void halt (void);
```
- `power_off()`를 호출해서 Pintos를 종료합니다.
	- `power_off()`는 src/include/threads/init.h에 선언
- 이 함수는 웬만하면 사용되지 않아야 합니다.
- deadlock 상황에 대한 정보 등등 뭔가 조금 잃어 버릴지도 모릅니다.


```c
void exit (int status);
```
- 현재 동작중인 유저 프로그램을 종료합니다.
- 커널에 상태를 리턴하면서 종료합니다. 
- 만약 부모 프로세스가 현재 유저 프로그램의 종료를 기다리던 중이라면, 그 말은 종료되면서 리턴될 그 상태를 기다린다는 것 입니다. 
- 관례적으로, 상태 0 은 성공을 뜻하고 0 이 아닌 값들은 에러를 뜻 합니다.


```c
pid_t fork (const char *thread_name);
```
- `thread_name` 이라는 이름을 가진 현재 프로세스의 복제본인 새 프로세스를 만듭니다.
- 피호출자(callee) 저장 레지스터인 `%rbx`, `%rsp`, `%rbp`, `%r12` ~ `%r15` 제외한 레지스터 값을 복제할 필요가 없습니다. 
- 자식 프로세스의 pid를 반환해야 합니다. 
	- 그렇지 않으면 유효한 pid가 아닐 수 있습니다. 
- 자식 프로세스에서 반환 값은 0이어야 합니다. 
- 자식 프로세스에는 파일 식별자 및 가상 메모리 공간을 포함한 복제된 리소스가 있어야 합니다.
- 부모 프로세스는 자식 프로세스가 성공적으로 복제되었는지 여부를 알 때까지 fork에서 반환해서는 안 됩니다. 
	- 즉, 자식 프로세스가 리소스를 복제하지 못하면 부모의 fork() 호출이 TID_ERROR를 반환할 것입니다.
- 템플릿은 `threads/mmu.c`의 `pml4_for_each`를 사용하여 해당되는 페이지 테이블 구조를 포함한 전체 사용자 메모리 공간을 복사하지만, 전달된 `pte_for_each_func`의 누락된 부분을 채워야 합니다.


```c
int exec (const char *cmd_line);
```
- 현재의 프로세스가 `cmd_line`에서 이름이 주어지는 실행가능한 프로세스로 변경됩니다.
- 이때 주어진 인자들을 전달합니다. 
- 성공적으로 진행된다면 어떤 것도 반환하지 않습니다. 
- 만약 프로그램이 이 프로세스를 로드하지 못하거나 다른 이유로 돌리지 못하게 되면 exit state -1을 반환하며 프로세스가 종료됩니다.
- 이 함수는 `exec` 함수를 호출한 쓰레드의 이름은 바꾸지 않습니다.
- file descriptor는 exec 함수 호출 시에 열린 상태로 있다는 것을 알아두세요.


```c
int wait (pid_t pid);
```
- 자식 프로세스 (pid) 를 기다려서 자식의 종료 상태(exit status)를 가져옵니다. 
- 만약 pid (자식 프로세스)가 아직 살아있으면, 종료 될 때 까지 기다립니다.
- 종료가 되면 그 프로세스가 exit 함수로 전달해준 상태(exit status)를 반환합니다. 
- 만약 pid (자식 프로세스)가 `exit()` 함수를 호출하지 않고 커널에 의해서 종료된다면 (e.g exception에 의해서 죽는 경우), `wait(pid)` 는 -1을 반환해야 합니다. 
- 부모 프로세스가 `wait` 함수를 호출한 시점에서 이미 종료되어버린 자식 프로세스를 기다리도록 하는 것은 완전히 합당합니다만, 커널은 부모 프로세스에게 자식의 종료 상태를 알려주든지, 커널에 의해 종료되었다는 사실을 알려주든지 해야 합니다.

>[!check] 다음의 조건들 중 하나라도 참이면 wait 은 즉시 fail 하고 -1 을 반환
>1. pid 는 호출하는 프로세스의 직속 자식을 참조하지 않습니다. 
>오직 호출하는 프로세스가 fork() 호출 후 성공적으로 pid를 반환받은 경우에만, pid 는 호출하는 프로세스의 직속 자식입니다.
> 자식들은 상속되지 않는다는 점을 알아두세요
>  만약 A 가 자식 B를 낳고 B가 자식 프로세스 C를 낳는다면, A는 C를 기다릴 수 없습니다.
>   심지어 B가 죽은 경우에도요. 
>   프로세스 A가 wait(C) 호출하는 것은 실패해야 합니다. (조부모 없음, 부모만 있음)
>    마찬가지로, 부모 프로세스가 먼저 종료되버리는 고아 프로세스들도 새로운 부모에게 할당되지 않습니다.
>2. wait 를 호출한 프로세스가 이미 pid에 대해 기다리는 wait 를 호출한 상태 일 때 입니다.
>	즉, 한 프로세스는 어떤 주어진 자식에 대해서 최대 한번만 wait 할 수 있습니다.

프로세스들은 얼마든지 자식을 만들 수 있고 어떤 순서로도 `wait`할 수 있다.
자식 몇개로부터의 신호는 기다리지도 않고 종료

>[!warning] 한 프로세스의 자원들은 꼭 마지막에 할당 해제되어야 한다.

>[!warning] 최초의 process가 종료되기 전에 Pintos가 종료되지 않도록 하십시오. 
>제공된 Pintos 코드는 `main()` (in `threads/init.c`)에서 `process_wait()` (in `userprog/process.c`) 를 호출하여 Pintos가 최초의 process 보다 먼저 종료되는 것을 막으려고 시도합니다. 
>여러분은 함수 설명의 제일 위의 코멘트를 따라서 `process_wait()` 를 구현하고 `process_wait()` 의 방식으로 wait system call을 구현해야 할 겁니다.


```c
bool create (const char *file, unsigned initial_size);
```
- 위의 함수는 `file`(첫 번째 인자)를 이름으로 하고 크기가 `initial_size`(두 번째 인자)인 새로운 파일을 생성합니다. 
- 성공적으로 파일이 생성되었다면 true를 반환하고, 실패했다면 false를 반환합니다.
- 새로운 파일을 생성하는 것이 그 파일을 여는 것을 의미하지는 않습니다.
- 파일을 여는 것은 `open` 시스템콜의 역할로, ‘생성’과 개별적인 연산입니다.


```c
bool remove (const char *file);
```
- 위의 함수는 file(첫 번째)라는 이름을 가진 파일을 삭제합니다. 
- 성공적으로 삭제했다면 true를 반환하고, 그렇지 않으면 false를 반환합니다. 
- 파일은 열려있는지 닫혀있는지 여부와 관계없이 삭제될 수 있고, 파일을 삭제하는 것이 그 파일을 닫았다는 것을 의미하지는 않습니다.


```c
int open (const char *file);
```
- 위의 함수는 file(첫 번째 인자)이라는 이름을 가진 파일을 엽니다. 
- 해당 파일이 성공적으로 열렸다면, 파일 식별자로 불리는 비음수 정수(0또는 양수)를 반환하고, 실패했다면 -1를 반환합니다. 
- 0번 파일식별자와 1번 파일식별자는 이미 역할이 지정되어 있습니다.  (파일 식별자 전달)
- 0번은 표준 입력(`STDIN_FILENO`)을 의미하고 1번은 표준 출력(`STDOUT_FILENO`)을 의미합니다.
- `open` 시스템 콜은 아래에서 명시적으로 설명하는 것처럼 시스템 콜 인자로서만 유효한 파일 식별자들을 반환하지 않습니다. 
- 각각의 프로세스는 독립적인 파일 식별자들을 갖습니다. 
- 파일 식별자는 자식 프로세스들에게 상속(전달)됩니다. 
- 하나의 프로세스에 의해서든 다른 여러개의 프로세스에 의해서든, 하나의 파일이 두 번 이상 열리면 그때마다 `open` 시스템콜은 새로운 식별자를 반환합니다. 
- 하나의 파일을 위한 서로 다른 파일 식별자들은 개별적인 `close` 호출에 의해서 독립적으로 닫히고 그 한 파일의 위치를 공유하지 않습니다. 
- 당신이 추가적인 작업을 하기 위해서는 open 시스템 콜이 반환하는 정수(`fd`)가 0보다 크거나 같아야 한다는 리눅스 체계를 따라야 합니다.

```c
bool remove (const char *file);
```
- 위의 함수는 file(첫 번째)라는 이름을 가진 파일을 삭제합니다. 
- 성공적으로 삭제했다면 true를 반환하고, 그렇지 않으면 false를 반환합니다. 
- 파일은 열려있는지 닫혀있는지 여부와 관계없이 삭제될 수 있고, 파일을 삭제하는 것이 그 파일을 닫았다는 것을 의미하지는 않습니다.


```c
int filesize (int fd);
```
- 위의 함수는 fd(첫 번째 인자)로서 열려 있는 파일의 크기가 몇 바이트인지 반환합니다.


 ```c
int read (int fd, void *buffer, unsigned size);
```
- buffer 안에 fd 로 열려있는 파일로부터 size 바이트를 읽습니다. 
- 실제로 읽어낸 바이트의 수 를 반환합니다 (파일 끝에서 시도하면 0). 
- 파일이 읽어질 수 없었다면 -1을 반환합니다.(파일 끝이라서가 아닌 다른 조건에 때문에 못 읽은 경우)


```c
int write (int fd, const void *buffer, unsigned size);
```
- `buffer`로부터 open file `fd`로 `size` 바이트를 적어줍니다. 
- 실제로 적힌 바이트의 수를 반환해주고, 일부 바이트가 적히지 못했다면 size보다 더 작은 바이트 수가 반환될 수 있습니다. 
- 파일의 끝을 넘어서 작성하는 것은 보통 파일을 확장하는 것이지만, 파일 확장은 basic file system에 의해서는 불가능합니다. 
- 이로 인해 파일의 끝까지 최대한 많은 바이트를 적어주고 실제 적힌 수를 반환하거나, 더 이상 바이트를 적을 수 없다면 0을 반환합니다.
- `fd` 1은 콘솔에 적어줍니다. 
- 콘솔에 작성한 코드가 적어도 몇 백 바이트를 넘지 않는 사이즈라면, 한 번의 호출에 있는 모든 버퍼를 `putbuf()`에 적어주는 것입니다.(더 큰 버퍼는 분해하는 것이 합리적입니다!)
- 그렇지 않다면, 다른 프로세스에 의해 텍스트 출력 라인들이 콘솔에 끼게 (interleaved)되고, 읽는 사람과 우리 채점 스크립트가 헷갈릴 것입니다.


```c
void seek (int fd, unsigned position);
```
- open file fd에서 읽거나 쓸 다음 바이트를 position으로 변경합니다. 
- position은 파일 시작부터 바이트 단위로 표시됩니다. (따라서 position 0은 파일의 시작을 의미합니다). 
- 이후에 read를 실행하면 파일의 끝을 가리키는 0바이트를 얻습니다. 
- 이후에 write를 실행하면 파일이 확장되어 기록되지 않은 공백이 0으로 채워집니다. (하지만 Pintos에서 파일은 프로젝트 4가 끝나기 전까지 길이가 고정되어 있기 때문에 파일의 끝을 넘어서 작성하려고 하면 오류를 반환할 것입니다.) 
- 이러한 의미론은 filesystem 안에서 구현되며 system call을 구현할 때에는 특별히 노력할 필요는 없습니다.


```c
unsigned tell (int fd);
```
- 열려진 파일 fd에서 읽히거나 써질 다음 바이트의 위치를 반환합니다.
- 파일의 시작지점부터 몇바이트인지로 표현됩니다.


```c
void close (int fd);
```
- 파일 식별자 fd를 닫습니다. 
- 프로세스를 나가거나 종료하는 것은 묵시적으로 그 프로세스의 열려있는 파일 식별자들을 닫습니다.
- 마치 각 파일 식별자에 대해 이 함수가 호출된 것과 같습니다.


각 시스템 콜에 대한 user-level 함수를 lib/user/syscall.c 파일에서 제공하고 있습니다.
이 함수들은 C 프로그램에서 유저 프로세스들이 각 시스템 콜을 호출하는 방법을 제공합니다. 
각각의 함수들은 시스템 콜을 호출하기 위한 짧은 어셈블리 코드를 사용하고 있고, 제대로 시스템 콜이 호출되었을 경우 반환 값을 리턴합니다.
