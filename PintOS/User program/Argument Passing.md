`process_exec()` 함수에 있는 유저 프로그램을 위한 인자 세팅


### x86-64 시스템에서의 호출 규약

>1. 유저-레벨 어플리케이션은 `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9` 시퀀스들을 전달하기 위해 정수 레지스터를 사용합니다.
>2. 호출자는 다음 인스트럭션의 주소(리턴 어드레스)를 스택에 푸시하고, 피호출자의 첫번째 인스트럭션으로 점프합니다. `CALL` 이라는 x86-64 인스트럭션 하나가 이 두 가지를 모두 수행합니다.
>3. 피호출자가 실행됩니다.
>4. 만약 피호출자가 리턴 값을 가지고 있다면, 리턴 값은 레지스터 `RAX`에 저장됩니다.
>5. 피호출자는 x86-64 인스트럭션인 `RET` (리턴)를 사용해서, 스택에 받았던 리턴 어드레스를 pop하고 그 주소가 가리키는 곳으로 점프함으로써 리턴됩니다.

세 개의 정수 인자를 받는 함수 f() 가 있다고 생각해봅시다. 

아래 도식은 위의 3번 항목에 있는 피호출자가 실행되는 시점에, 스택 프레임과 레지스터 상태가 어떤 식으로 되어있는지에 대한 예시를 보여줍니다.
`f()`가 `f(1, 2, 3)`으로 호출되었다고 가정합시다. 초기화된 스택의 주소는 임의의 숫자로 치면 다음과 같습니다.
```
                             +----------------+
stack pointer --> 0x4747fe70 | return address |
                             +----------------+
RDI: 0x0000000000000001 | RSI: 0x0000000000000002 | RDX: 0x0000000000000003
```


### 프로그램 시작과 관련된 디테일

유저 프로그램을 위한 Pintos C 라이브러리는 `_start()` 함수를 유저 프로그램의 시작 포인트로 지정
`_start()` in `lib/user/entry.c`
여기서 `_start()`는 `main()` 함수를 감싸고 있는 함수
`main()` 은 리턴되면서 `exit()`을 호출

```c
void _start (int argc, char *argv[]) 
{ 
	exit (main (argc, argv)); 
}
```


`/bin/ls -l foo bar` 와 같은 명령이 주어졌을 때, 인자들을 어떻게 다뤄야 하는지 생각해봅시다.

>1. 명령을 단어들로 쪼갠다. → `/bin/ls`, `l`, `foo`, `bar` 
>2. 이 단어들을 스택의 맨 처음 부분에 놓는다.
>	순서는 상관 X,  왜냐면 포인터에 의해 참조될 예정이기 때문
>3. 각 문자열의 주소 + 경계조건을 위한 널포인터를 스택에 오른쪽→왼쪽 순서로 푸시
>	이들은 `argv`의 원소가 된다.
>	널포인터 경계는 `argv[argc]` 가 널포인터라는 사실을 보장 (C언어 표준의 요구사항에 맞춰서) 그리고 이 순서는 `argv[0]`이 가장 낮은 가상 주소를 가진다는 사실을 보장
>	또한 word 크기에 정렬된 접근이 정렬되지 않은 접근보다 빠르므로, 최고의 성능을 위해서는 스택에 첫 푸시가 발생하기 전에 스택포인터를 8의 배수로 반올림하여야 한다.
>4. `%rsi` 가 `argv` 주소(`argv[0]`의 주소)를 가리키게 하고, `%rdi` 를 `argc` 로 설정
	RDI: 4 | RSI: 0x4747ffc0
>5.  마지막으로 가짜 “return 주소”를 푸시
>	entry 함수는 절대 리턴되지 않겠지만, 해당 스택 프레임은 다른 스택 프레임들과 같은 구조를 가져야 한다.


아래의 표는 스택과 관련 레지스터들이 유저 프로그램이 시작되기 직전에 어떤 상태인지를 보여준다.
(스택은 아래 방향으로 커진다.)

| Address    | Name           | Data        | Type        |
| ---------- | -------------- | ----------- | ----------- |
| 0x4747fffc | argv[3][...]   | 'bar\0'     | char[4]     |
| 0x4747fff8 | argv[2][...]   | 'foo\0'     | char[4]     |
| 0x4747fff5 | argv[1][...]   | '-l\0'      | char[3]     |
| 0x4747ffed | argv[0][...]   | '/bin/ls\0' | char[8]     |
| 0x4747ffe8 | word-align     | 0           | uint8_t[]   |
| 0x4747ffe0 | argv[4]        | 0           | char *      |
| 0x4747ffd8 | argv[3]        | 0x4747fffc  | char *      |
| 0x4747ffd0 | argv[2]        | 0x4747fff8  | char *      |
| 0x4747ffc8 | argv[1]        | 0x4747fff5  | char *      |
| 0x4747ffc0 | argv[0]        | 0x4747ffed  | char *      |
| 0x4747ffb8 | return address | 0           | void (*) () |
|            |                |             |             |

스택 포인터는 위에 보이는 것처럼 0x4747ffb8로 초기화될 것이고,
당신의 코드는 `include/threads/vaddr.h`에 정의된 `USER_STACK` 값에서부터 스택을 시작시켜야 한다.

### 인자 전달 구현

현재, `process_exec()` 함수는 새로운 프로세스들에 인자를 전달하는 것 지원 X

>[!tip] `process_exec()` 함수 확장 구현
지금처럼 단순히 프로그램 파일 이름만을 인자로 받아오게 하는 대신 공백을 기준으로 여러 단어로 나누어지게 만들어야 한다.
첫 번째 단어는 프로그램 이름이고, 두 번째 단어는 첫 번째 인자이며, 그런 식으로 계속 이어지게 만들면 된다.
>
 `process_exec("grep foo bar")` :  두 개의 인자 `foo`와 `bar`을 받아서 `grep` 프로그램을 실행


>[!warning]
>커맨드라인에서, 여러개의 공백은 하나의 공백과 같게 처리
>`process_exec("grep           foo bar")`는 위의 원본 예시와 동일하게 동작
