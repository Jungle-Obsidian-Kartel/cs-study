여러분의 핀토스가 리눅스의 ==`stdin`, `stdout` 를 닫는 기능과 `dup2` 시스템 콜을 지원하도록== 만들어보세요.

현재 구현된 핀토스에서는 `stdin`과 `stdout` 파일 디스크립터를 닫는 것이 금지되어있습니다. 
이번 여분 과제에서 여러분의 핀토스가 리눅스처럼 유저가 `stdin`과 `stdout`을 닫을 수 있도록 해보세요.
즉, 프로세스가 `stdin` 를 닫으면 절대 input을 읽을 수 없고, `stdout`을 닫으면 어떤 것도 출력할 수 없게 만들어보세요.

다음으로는, ==`dup2` 시스템 콜==을 구현해보세요.

```c
int dup2(int oldfd, int newfd);
```

`dup2()` 시스템 콜은 인자로 받은 oldfd 파일 디스크립터의 복사본을 생성하고, 이 복사본의 파일디스크립터 값은 인자로 받은 `newfd` 값이 되게 합니다. 
`dup()` 시스템 콜이 파일 디스크립터를 복사해서 새 파일 디스크립터를 생성하는 데 성공한다면 `newfd`를 리턴합니다. 만약 `newfd` 값이 이전에 이미 열려있었다면, `newfd`는 재사용되기 전에 조용히 닫힙니다. 

>[!check] 아래 사항들을 기억하세요.   
▪️ 만약 `oldfd` 가 유효한 파일 디스크립터가 아니라면, dup2() 콜은 실패하여 1을 반환하고, newfd 는 닫히지 않습니다.   
▪️ 만약 oldfd 가 유효한 파일 디스크립터이고, newfd는 oldfd와 같은 값을 가지고 있다면 dup2()가 할일은 따로 없고 (*이미 같으므로) newfd 값을 리턴합니다. 

이 시스템콜로부터 성공적으로 값을 반환받은 후에, oldfd와 newfd는 호환해서 사용이 가능합니다.
이 둘은 서로 다른 파일 디스크립터이긴하지만, 똑같은 열린 파일 디스크립터를 의미하기 때문에 같은 file offset과 status flags 를 공유하고 있습니다. 
예를 들어 만약에 다른 디스크립터가 seek 을 사용해서 file offset이 수정되었다면, 다른 스크립터에서도 이 값은 똑같이 수정됩니다.